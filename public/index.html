<html>
  <script src="lib/jquery-3.1.0.min.js"></script>
  <script src="lib/tether.min.js"></script>
  <!-- Latest compiled and minified CSS -->
  <link rel="stylesheet" href="lib/bootstrap/3.3.7/css/bootstrap.min.css">
  <!-- Optional theme -->
  <link rel="stylesheet" href="lib/bootstrap/3.3.7/css/bootstrap-theme.min.css">
  <!-- Latest compiled and minified JavaScript -->
  <script src="lib/bootstrap/3.3.7/js/bootstrap.min.js"></script>
  <script src="lib/ace/ace.js" type="text/javascript" charset="utf-8"></script>
  
  <link href="lib/bootstrap-treeview/css/bootstrap-treeview.css" rel="stylesheet">
  <script src="lib/bootstrap-treeview/js/bootstrap-treeview.js"></script>

  <!--<script src="lib/jquery.json-view/jquery.json-view.js"></script>
  <link href="lib/jquery.json-view/jquery.json-view.css" rel="stylesheet">
   -->
  <link href="app.css" rel="stylesheet" type="text/css">
  
  
  <body>
    
    <div id="desk">
        
        <div id="main_desk" class="flex-container">
            <div id="grammar_container" class="flex-grammar">
                <label for="richtext_grammar_container">PEG Grammar
                    <span id="result_indicator" class="no_match">no match</span>
                </label>
                <div id="richtext_grammar_container" class="richtext_container overflow_handler">
                    <div id="richtext_grammar" class="richtext">
{
func toIfaceSlice(v interface{}) []interface{} {
    if v == nil {
        return nil
    }
    return v.([]interface{})
}
} 

RootNode <- #{ state["Indentation"] = 0; return nil } (RootStatement)+ EOF
RootStatement <- Node / VarNode / FunctionNode
Node <-  ( Slash? ( ( IsNode Identifier Slash Node) / (IsNode Identifier EOL+ INDENT (INDENTATION Node EOL*)* DEDENT)) )  / NodeStatement
NodeStatement <- VarNode / ProcNode / VerbNode / FunctionNode / EOL
IsNode <- !"var" !"proc" !"verb"
Assignment <- LValue _? AssignmentOp _? Initializer
LValue <- ArrayAccess / VarDefinition
AssignmentOp <- [-+*/]? "=" 
Initializer <- Expression
 
VarNode <-  Slash? ( ("var" Slash VarNodeScope) / ("var" EOL+ INDENT (INDENTATION VarNodeScope)* DEDENT) ) / (Assignment EOL)
VarNodeScope <- (Identifier Slash VarNodeType) / (Identifier EOL+ INDENT (INDENTATION VarNodeType)* DEDENT) / VarNodeType
VarNodeType <- (Identifier Slash VarNodeStatement) / (Identifier EOL+ INDENT (INDENTATION VarNodeStatement)* DEDENT) / VarNodeStatement
VarNodeStatement <- ( Assignment / ListVariable / SimpleVariable  ) EOL
SimpleVariable <- Identifier
ListVariable <- Identifier ('[' _? Expression? _?']')+

ProcNode <- Slash? ( ("proc" Slash FunctionNode) / ("proc" EOL+ INDENT (INDENTATION FunctionNode)* DEDENT) ) 
VerbNode <- Slash? ( ("verb" Slash FunctionNode) / ("verb" EOL+ INDENT (INDENTATION FunctionNode)* DEDENT) ) 

FunctionNode <- Identifier '(' ArgumentsList? ')'  EOL+ INDENT (INDENTATION (FunctionStatement) EOL*)+ EOL* DEDENT

FunctionStatement <- VarNode / ReturnStatement / IfStatement / Assignment / OutputInstruction / InputInstruction 
                    / DelInstruction / SleepInstruction / SpawnInstruction / ForStatement / SwitchStatement / CallStatement / EOL

ReturnStatement <- "return" _ (Expression)?
CallStatement <- Expression
DelInstruction <- "del" _ VarDefinition
SleepInstruction <- "sleep" '(' _? Constant _? ')' LoopBlock
SpawnInstruction <- "spawn" _? '(' _? Constant _? ')' LoopBlock
InputInstruction  <- "input" '(' _? Expression _? ','_? Expression _? ','_? Expression _? ','_? Expression ')' "as input-type in List"
OutputInstruction <- OutputTarget _? "<<" _? OutputMethod
OutputTarget <- PrefixExpression
OutputMethod <- StringLiteral / (("text" / "file" / "image" / "browse" / "sound" / "ftp" / "run" / "link") "()")

IfStatement <- IfGroup ElIfGroup* ElseGroup?      
IfGroup         <- "if" _? '(' _? Expression _? ')' LoopBlock  
ElIfGroup       <-  INDENTATION "else if" _? '(' _? Expression _? ')' LoopBlock
ElseGroup       <-  INDENTATION "else" LoopBlock

SwitchStatement <- "switch" '(' _? Expression _? ')' SwitchBlock
SwitchBlock <- EOL+ INDENT (INDENTATION CaseStatement)+ DEDENT
CaseStatement <- CaseIfStatement / CaseElseStatement
CaseIfStatement <- "if" _? '(' _? Constant _? ')' LoopBlock
CaseElseStatement <- "else" LoopBlock

ForStatement <- ForEachStatement / ForConditionalStatement / WhileStatement / DoWhileStatement
ForEachStatement <- "for" '(' _? ForEachVariable (_ "as" _ ForEachInputType)? _ "in" _ ForEachList ')' LoopBlock
ForEachVariable <- VarDefinition
ForEachInputType <- InputType
ForEachList <- PrimaryExpression
ForConditionalStatement <- "for" '(' _? (VarNode / Assignment) _? (';'/',') _? ConditionalExpression _? (';'/',') _? Expression _? ')'  LoopBlock
WhileStatement <- "while" '(' _? ConditionalExpression _? ')' LoopBlock
DoWhileStatement <- "do" LoopBlock "while" '(' _? ConditionalExpression _?')' EOL

LoopBlock <- (EOL+ INDENT (INDENTATION LoopStatement EOL*)+   DEDENT) / ( _ LoopStatement EOL*)
LoopStatement <- "break"  / "continue" / FunctionStatement

Expression              <- v:ConditionalExpression                
ConditionalExpression   <- v:LogicalOrExpression ( _? '?' _? Expression _? ":" _? Expression )? 
LogicalOrExpression     <- v:LogicalAndExpression rest:( _? "||" _? LogicalAndExpression )*                  
LogicalAndExpression    <- v:InclusiveOrExpression rest:( _? "&&" _? InclusiveOrExpression )*                
InclusiveOrExpression   <- v:ExclusiveOrExpression rest:( _? '|' _? ExclusiveOrExpression )*                 
ExclusiveOrExpression   <- v:AndExpression rest:( _? '^' _? AndExpression )*                                 
AndExpression           <- v:EqualityExpression rest:( _? '&' _? EqualityExpression )*                       
EqualityExpression      <- v:ShiftExpression rest:( _? ( "==" / "!=" / "<>" ) _? ShiftExpression )*          
ShiftExpression         <- v:RelationalExpression rest:( _? ( "<<" / ">>" ) _? RelationalExpression )*       
RelationalExpression    <- v:ContainExpression rest:( _? ( ">=" / "<=" / '>' / '<' ) _? ContainExpression )*  
ContainExpression       <- v:AdditiveExpression rest:( _ ( "in" ) _ AdditiveExpression )* 
AdditiveExpression      <- v:MultiplicativeExpression rest:( _? ( '+' / '-' ) _? MultiplicativeExpression )* 
MultiplicativeExpression <- v:PowerExpression rest:( _? ( '*' / '/' / '%' ) _? PowerExpression )*          
PowerExpression         <- v:UnaryExpression rest:( _? ( "**" ) _? UnaryExpression )*          
UnaryExpression        <- u:(UnaryOperator?) v:PostfixExpression     
UnaryOperator           <- ( '!' / '~' / "++" / "--" / '-' )
PostfixExpression        <- v:PrefixExpression rest:( "++" / "--" )?
PrefixExpression       <- MethodCall
MethodCall <- ArrayAccess ( "(" ExpressionList? ")" )*
ArrayAccess <- MemberAccess ( "[" Expression "]" )*
MemberAccess <- PrimaryExpression ( "." Identifier)*
PrimaryExpression       <- 
                        FloatLiteral
                        / IntegerLiteral     
                        / CharacterLiteral
                        / StringLiteral
                        / ('(' _?  v:Expression _? ')' )
                        / v:Identifier
                        / v:VarDefinition
                        / v:VarAbsDefinition
                        / '.'

Constant                <- PrimaryExpression

InputTypeCombination <- InputType ('|' InputType)*
InputType <- "text" / "message" / "num" / "icon" / "sound" 
            / "file" / "key" / "null" / "mob" / "obj"
            / "turf" / "area" / "anything"

VarDefinition <- Identifier (Slash Identifier)*
VarAbsDefinition <- (Slash Identifier)+

ArgumentsList <-  _? Argument _? (',' _? Argument _? )* 
Argument <- ArgumentName (_? "=" _? ArgumentDefaultValue)? (_ "as" _ ArgumentType ("|"ArgumentAnythingType)? (_ "in" _ ArgumentLimitList)?)?
ArgumentName <- VarDefinition
ArgumentDefaultValue <- PrimaryExpression 
ArgumentType <- Identifier
ArgumentAnythingType <- "anything"
ArgumentLimitList <- Expression

ExpressionList          <- InitializerList
InitializerList         <- _? InitializerClause _? (',' _? InitializerClause _? )*
InitializerClause       <- AssignmentExpression / ConditionalExpression 
AssignmentExpression    <-  ConditionalExpression _? '=' _? ConditionalExpression
                        
IntegerLiteral          <- DecimalLiteral / OctalLiteral / HexadecimalLiteral
DecimalLiteral          <- NonzeroDigit Digit*         { v,err := strconv.ParseInt(string(c.text), 0, 64); return int(v),err }
OctalLiteral            <- '0' OctalDigit*             { v,err := strconv.ParseInt(string(c.text), 0, 64); return int(v),err }
HexadecimalLiteral      <- '0' [xX]  HexadecimalDigit+ { v,err := strconv.ParseInt(string(c.text), 0, 64); return int(v),err }
Digit <- [0-9]
NonzeroDigit <- [1-9]
OctalDigit <- [0-7]	

FloatLiteral <- FractionalConstant ExponentPart? / Digit+ ExponentPart
FractionalConstant <-  (Digit* '.' Digit+)  / (Digit+ '.')
ExponentPart <- [eE] Sign? Digit+

StringLiteral   <- '"'  val:SCharSequence? '"'                   
SCharSequence   <- val:SChar+                                    
SChar           <- val:(EmbeddedLiteral / EscapeSequence / AnyExceptNlDqBs)     
AnyExceptNlDqBs <- [^\x0d\x0a"\\]                                               
EscapeSequence          <- (SimpleEscapeSequence / HexadecimalEscapeSequence)   
SimpleEscapeSequence    <- '\\' ["[\]\\/bfnrt]
HexadecimalEscapeSequence <- '\\' 'x' HexadecimalDigit+
HexadecimalDigit        <- [0-9a-f]i
EmbeddedLiteral    <- '[' _? val:EmbeddedExpr _? ']' 
EmbeddedExpr <- !']' v:Expression 

CharacterLiteral <- "'" CCharSequence "'"                        
CCharSequence    <- CChar+
CChar            <- EscapeSequence / AnyExceptNlSqBs 
AnyExceptNlSqBs <- [^\x0d\x0a'\\]

Identifier <- [a-zA-Z_] [a-zA-Z0-9_]*
    
Slash <- '/'
_ <- [ \t]+
EOL <- _? NL 
NL  <- "\r\n" / "\n\r" / "\r" / "\n"
EOF <- !.

INDENTATION <- spaces:"\t"* &{ return len(toIfaceSlice(spaces)) == state["Indentation"].(int), nil }
INDENT <- #{ state["Indentation"] = state["Indentation"].(int) + 1; return nil }
DEDENT <- #{ state["Indentation"] = state["Indentation"].(int) - 1; return nil }</div>
                </div>
            </div>
            <div id="test_container" class="flex-text scroll_y">
                <label for="richtext_test_container">Test string</label>
                <div id="richtext_test_container" class="richtext_container overflow_handler">
                    <div id="richtext_test" class="richtext">/atom/var/smooth = 0
/obj/screen/human/toggle/Click()
	density = 1

turf
	floor
		var/x = 1
		icon = 1
		proc/p1(x)
			var/z = 2

	wall
		icon = 0
		density = 1
		opacity = 1
		
		secret_door
			name = 0
			density = 0

	window
		icon = 1
		density = 1
</div>
                </div>
            </div>
        </div>

        <div id="info_desk" class="flex-container scroll_y">
                <div id="output_container" class="flex-elem">
                    <label for="richtext_output_container">Output</label>
                    <div id="richtext_output_container" class="overflow_handler">
                        <div id="richtext_output" class="richtext">Output will be displayed here automatically.</div>
                     </div>
                </div>
        </div>
    
    </div>
        
    <script>
    var url = "ws://" + window.location.host + "/api/ws";
    var ws = new WebSocket(url);
    var output = document.getElementById("richtext_output");
    
    var geditor = ace.edit("richtext_grammar");
    geditor.setTheme("ace/theme/chrome");
    //editor.getSession().setMode("ace/mode/pegjs");
    var teditor = ace.edit("richtext_test");
    teditor.setTheme("ace/theme/chrome");
    //editor.getSession().setMode("ace/mode/javascript");
    var Range = ace.require('ace/range').Range;


    //adding a tooltip
    var entries = [];
    var markers = [];    

    var getRulesByIdx = function(entries,idx) {
        var isTransientRule = function(e) {
            if (e.detail.name == "ZeroOrOneExpr" ||
                e.detail.name == "OneOrMoreExpr" ||
                e.detail.name == "ZeroOrMoreExpr")
                return true;
            return false;
        }
        var walk = function(e) {
            switch($.type(e)) {
                case 'object':
                    found = walk(e.calls);
                    if (found !== null) {
                        //if (e.ismatch || isTransientRule(e)) {
                            // revert order
                            var x = found
                            while (x.caller !== null) {
                                x = x.caller
                            }
                            e['caller'] = null
                            x.caller = e
                            return found;
                        //}
                    }
                    
                    if (e.ismatch) {
                        if (e.detail.idx1 <= idx && idx < e.detail.idx2) {
                            e['caller'] = null
                            return e;
                        }
                    } 
                    return null
                    
                case 'array':
                    var found = null
                    $.each(e, function(k,v) {
                        found = walk(v)
                        if (found !== null) {
                            return false; // break each
                        }
                    });
                            
                    if (e.length == 0 )
                        return null;
                    return found;
            }
            
       };
       return walk(entries); 
    }

    function mergeText(v) {
        var text = '';
        var e = v
        while (e !== null) {
            if (e.ismatch)
                color = 'green'
            else
                color = 'gray';
            text += '<font color="'+color+'">' + e.detail.name + '</font><br>';
            e = e.caller
        }
        return text
    }
    teditor.on("mousemove", function (e){
        var position = e.getDocumentPosition();
        if (position) {
            idx = teditor.session.getDocument().positionToIndex(position,0);
            v = getRulesByIdx(entries,idx);
            var text = mergeText(v);
            if (text.length > 0) {
                var pixelPosition = teditor.renderer.textToScreenCoordinates(position);
                pixelPosition.pageY += teditor.renderer.lineHeight;
                updateTooltip(pixelPosition, text);
            }else{
                updateTooltip(teditor.renderer.textToScreenCoordinates(position));
            }
            markers.forEach(function(e) {
                teditor.session.removeMarker(e);
            });
            markers = [];
            color = 0
            g = v
            while (g !== null) {
                coloridx = color % 20 + 1
                color += 1
                bracket_class = "mark_bracket"+coloridx
                p1 = teditor.session.getDocument().indexToPosition(g.detail.idx1,0);
                p2 = teditor.session.getDocument().indexToPosition(g.detail.idx2,0);
                range = new Range(p1.row, p1.column, p2.row, p2.column);
                markers.push(teditor.session.addMarker(range, bracket_class, "text"));
                g = g.caller
            }
            
            
        }
    });
    
    function updateTooltip(position, text){
            var div = document.getElementById('rule_tooltip_0');
            if(div === null){
                div = document.createElement('div');        
                div.setAttribute('id', 'rule_tooltip_0'); 
                div.setAttribute('class', 'rule_tooltip'); 
                document.body.appendChild(div);
            }

            div.style.left = position.pageX + 'px';
            div.style.top = position.pageY + 'px';
            if(text){
                div.style.display = "block";
                div.innerHTML = text;
            }else{
                div.style.display = "none";
                div.innerHTML = "";
            }           

        }

    function genJSONTree(t) {
       var genNode = function(data) {
            switch($.type(data)) {
                case 'object':
                    var node = {text: '', nodes: null, vidx2: 0};
                    var match = '';
                    if (data.ismatch) {
                        match = data.detail.idx2;
                    } else {
                        match = '_'
                        node.vidx2 = data.detail.idx2;
                    }
                    node.text = "[" + data.detail.idx1 + ',' + match + '] ' + data.detail.name;
                    node.nodes = genNode(data.calls);
                    return node
                    
                case 'array':
                    var nodes = [];
                    $.each(data, function(k,v) {
                        node = genNode(v)
                        nodes.push(node)
                    });
                    if (nodes.length == 0 )
                        return null;
                    return nodes;
            }
            
       };
       return genNode(t); 
    }

    var onTreeNodeUnselected = function(event, data) {
        markers.forEach(function(e) {
            teditor.session.removeMarker(e);
        });
        markers = []
    }
    var onTreeNodeSelected = function(event, data) {
        var x1 = 0
        var x2 = 0
        bracket_class = ""
        var r_nonmatch = /^\[(\d+),_\].+/i
        var r_match = /^\[(\d+),(\d+)\].+/i
        m = r_nonmatch.exec(data.text)
        if (m !== null) {
            x1 = parseInt(m[1])
            x2 = data.vidx2
            bracket_class = "mark_bracket9"
        }
        m = r_match.exec(data.text)
        if ( m !== null) {
            x1 = parseInt(m[1])
            x2 = parseInt(m[2])
            bracket_class = "mark_bracket1"
        }
                        
        markers.forEach(function(e) {
            teditor.session.removeMarker(e);
        });
        markers = []
        p1 = teditor.session.getDocument().indexToPosition(x1,0);
        p2 = teditor.session.getDocument().indexToPosition(x2,0);
        range = new Range(p1.row, p1.column, p2.row, p2.column);
        markers.push(teditor.session.addMarker(range, bracket_class, "text"));
    }
    
    var start_time = 0;
    var idle_timer = null
    ws.onmessage = function (msg) {
    	output.innerText = "";
        t = JSON.parse(msg.data);
        if (t.errors != "") {
            $('#richtext_output').text(t.errors)
            $('#result_indicator').text('error');
            return;
        }
        $('#richtext_output').treeview({data: genJSONTree(t.entries)});
        $('#richtext_output').on('nodeSelected', onTreeNodeSelected);
        $('#richtext_output').on('nodeUnselected', onTreeNodeUnselected);
        entries = t.entries
        exec_time = performance.now() - start_time;
        $('#result_indicator').text(Math.round(exec_time) + 'ms');
    };
    geditor.on("change", function (e) {
        if (idle_timer !== null)
            clearTimeout(idle_timer);
        var send = function() {
            jmsg = JSON.stringify({ grammar: geditor.session.getDocument().getValue(), test_string: teditor.session.getDocument().getValue() })
            start_time = performance.now();
            $('#result_indicator').text('wait');
            ws.send(jmsg);
        }
        idle_timer = setTimeout(send,2000)
    });

    </script>
  </body>
</html>