<html>
  <script src="lib/jquery-3.1.0.min.js"></script>
  <script src="lib/tether.min.js"></script>
  <!-- Latest compiled and minified CSS -->
  <link rel="stylesheet" href="lib/bootstrap/3.3.7/css/bootstrap.min.css">
  <!-- Optional theme -->
  <link rel="stylesheet" href="lib/bootstrap/3.3.7/css/bootstrap-theme.min.css">
  <!-- Latest compiled and minified JavaScript -->
  <script src="lib/bootstrap/3.3.7/js/bootstrap.min.js"></script>
  <script src="lib/ace/ace.js" type="text/javascript" charset="utf-8"></script>
  
  <link href="lib/bootstrap-treeview/css/bootstrap-treeview.css" rel="stylesheet">
  <script src="lib/bootstrap-treeview/js/bootstrap-treeview.js"></script>

  <!--<script src="lib/jquery.json-view/jquery.json-view.js"></script>
  <link href="lib/jquery.json-view/jquery.json-view.css" rel="stylesheet">
   -->
  <link href="app.css" rel="stylesheet" type="text/css">
  
  
  <body>
    
    <div id="desk">
        
        <div id="main_desk" class="flex-container">
            <div id="grammar_container" class="flex-grammar">
                <label for="richtext_grammar_container">PEG Grammar
                    <span id="result_indicator" class="no_match">no match</span>
                </label>
                <div id="richtext_grammar_container" class="richtext_container overflow_handler">
                    <div id="richtext_grammar" class="richtext">
{
func toIfaceSlice(v interface{}) []interface{} {
    if v == nil {
        return nil
    }
    return v.([]interface{})
}
}

DmUnit <- 
    #{ state["Indentation"] = 0; return nil }  Statements EOF

Statements  <- 
    s:Line+

Line <-
    INDENTATION s:Statement

Statement <- 
     ObjDeclaration

ObjDeclaration <- 
    ObjIdentifier ObjBlock
ObjIdentifier <-
    Slash? (atom / datum / Identifier) (Slash (atom / datum / Identifier))* EOL
ObjBlock <-
    INDENT INDENTATION ((ObjDeclaration / ObjBlockStatement ) EOL+)+ DEDENT

Slash <- "/"
atom <-
    "atom"
  / "area"
  / "turf"
  / "obj"
  / "mob"
datum <-
     "datum"
  /  "world"
  /  "client"
  /  "list"

ObjBlockStatement <-
     VarAssignment
Identifier <-
     [a-zA-Z] [a-zA-Z0-9]* 

VarAssignment <-
     LValue _ AssignmentOp _ VarInitializer
LValue <- Identifier
AssignmentOp <- "="
VarInitializer <- [0-9]


_ <- [ \t]+

EOL <- _? ( NL / EOF)
NL  <- "\r\n" / "\n\r" / "\r" / "\n"
EOF <- !.

INDENTATION <- spaces:"\t"* &{ return len(toIfaceSlice(spaces)) == state["Indentation"].(int), nil }

INDENT <- #{ state["Indentation"] = state["Indentation"].(int) + 1; return nil }

DEDENT <- #{ state["Indentation"] = state["Indentation"].(int) - 1; return nil }</div>
                </div>
            </div>
            <div id="test_container" class="flex-text">
                <label for="richtext_test_container">Test string</label>
                <div id="richtext_test_container" class="richtext_container overflow_handler">
                    <div id="richtext_test" class="richtext">turf
	floor
		icon = 1

	wall
		icon = 0
		density = 1
		opacity = 1

		secret_door
			name = 0
			density = 0

	window
		icon = 1
		density = 1
</div>
                </div>
            </div>
        </div>

        <div id="info_desk" class="flex-container scroll_y">
                <div id="output_container" class="flex-elem">
                    <label for="richtext_output_container">Output</label>
                    <div id="richtext_output_container" class="overflow_handler">
                        <div id="richtext_output" class="richtext">Output will be displayed here automatically.</div>
                     </div>
                </div>
        </div>
    
    </div>
        
    <script>
    var url = "ws://" + window.location.host + "/api/ws";
    var ws = new WebSocket(url);
    var output = document.getElementById("richtext_output");
    
    var geditor = ace.edit("richtext_grammar");
    geditor.setTheme("ace/theme/chrome");

    var teditor = ace.edit("richtext_test");
    teditor.setTheme("ace/theme/chrome");
    //editor.getSession().setMode("ace/mode/javascript");
    var Range = ace.require('ace/range').Range;


    //adding a tooltip
    var entries = [];
    var markers = [];    

    teditor.on("mousemove", function (e){
        var position = e.getDocumentPosition();
        if (position) {
            posIdx = teditor.session.getDocument().positionToIndex(position,0);
            r = getRangesByPosIdx(entries,posIdx);
            var text = mergeTextByPosIdx(r,posIdx);
            if (text.length > 0) {
                var pixelPosition = teditor.renderer.textToScreenCoordinates(position);
                pixelPosition.pageY += teditor.renderer.lineHeight;
                updateTooltip(pixelPosition, text);
            }else{
                updateTooltip(teditor.renderer.textToScreenCoordinates(position));
            }
            markers.forEach(function(e) {
                teditor.session.removeMarker(e);
            });
            markers = [];
            color = 0
            r.forEach(function(e) {
                coloridx = color % 10 + 1
                color += 1
                bracket_class = "mark_bracket"+coloridx
                p1 = teditor.session.getDocument().indexToPosition(e.x1,0);
                p2 = teditor.session.getDocument().indexToPosition(e.x2,0);
                range = new Range(p1.row, p1.column, p2.row, p2.column);
                markers.push(teditor.session.addMarker(range, bracket_class, "text"));
            });
            
        }
    });

    function getRangesByPosIdx(arr, idx) {
        var r = [];
        arr.forEach(function(e) {
            if ((e.x1 <= idx) && (idx < e.x2)) {
                if ((r.length > 0) && (r[0].x1 <= e.x1) && (r[0].x2 >= e.x2)) {
                    r.unshift(e);
                } else {
                    r.push(e);
                }
        }   
        })
        return r;
    }

    function mergeTextByPosIdx(arr, idx) {
        var text = '';
        arr.forEach(function(e) {
            if ((e.x1 <= idx ) && (idx < e.x2)) {
                if (e.matched)
                    color = 'green'
                else
                    color = 'gray';
                text += '<font color="'+color+'">' + e.text + '</font><br>';
            }
        });
        return text
    }

    function updateTooltip(position, text){
            //example with container creation via JS
            var div = document.getElementById('rule_tooltip_0');
            if(div === null){
                div = document.createElement('div');        
                div.setAttribute('id', 'rule_tooltip_0'); 
                div.setAttribute('class', 'rule_tooltip'); // and make sure myclass has some styles in css
                document.body.appendChild(div);
            }

            div.style.left = position.pageX + 'px';
            div.style.top = position.pageY + 'px';
            if(text){
                div.style.display = "block";
                div.innerHTML = text;
            }else{
                div.style.display = "none";
                div.innerHTML = "";
            }           

        }

    
    function mark(x1, x2, text, matched) {
        entries.push({ x1:x1, x2:x2, text: text, matched: matched})
    }
    
    function traverse(jsonObj) {
        if( typeof jsonObj == "object") {
            $.each(jsonObj, function(k,v) {
                if ("calls" in v) {
                    var maxPos = v.detail.pos.Pos;
                    $.each(v.calls, function(u,r) {
                        if (r.match !== null) {
                            maxPos = Math.max(maxPos,r.match.pos.Pos);
                        }
                    });
                    var x2;                    
                    x1 = v.detail.pos.Pos
                    if (v.match !== null) {
                        x2 = v.match.pos.Pos;
                    } else {
                        x2 = maxPos;
                    }
                    mark(x1, x2, v.detail.name, (v.match !== null) )
                
                    traverse(v.calls);                    
                }
            });
        }
        else {
            // jsonOb is a number or string
        }
    }

    var markAllMatches = function(e) {
        entries = []
        traverse(e);
    };

    function genJSONTree(t) {
       var genBlock = function(data) {
            switch($.type(data)) {
                case 'object':
                    var node = {text: '', nodes: null};
                    var match = '';
                    if (data.match !== null) {
                        match = data.match.pos.Pos;
                    } else {
                        match = '_'
                    }
                    node.text = "[" + data.detail.pos.Pos + ',' + match + '] ' + data.detail.name;
                    node.nodes = genBlock(data.calls);
                    return node
                    
                case 'array':
                    var nodes = [];
                    $.each(data, function(k,v) {
                        node = genBlock(v)
                        nodes.push(node)
                    });
                    if (nodes.length == 0 )
                        return null;
                    return nodes;
                /*
                case 'string':
                    return data

                case 'number':
                    return data;

                case 'undefined':
                    return 'undefined';

                case 'null':
                    return 'null';

                case 'boolean':
                    return data;*/
            }
            
       };
       return genBlock(t); 
    }

    var maxidx;
    var onTreeNodeUnselected = function(event, data) {
        markers.forEach(function(e) {
            teditor.session.removeMarker(e);
        });
        markers = []
    }
    var onTreeNodeSelected = function(event, data) {
        var x1 = 0
        var x2 = 0
        bracket_class = ""
        var r_nonmatch = /^\[(\d+),_\].+/i
        var r_match = /^\[(\d+),(\d+)\].+/i
        m = r_nonmatch.exec(data.text)
        if (m !== null) {
            x1 = parseInt(m[1])
            x2 = maxidx
            bracket_class = "mark_bracket9"
        }
        m = r_match.exec(data.text)
        if ( m !== null) {
            x1 = parseInt(m[1])
            x2 = parseInt(m[2])
            bracket_class = "mark_bracket1"
        }
        markers.forEach(function(e) {
            teditor.session.removeMarker(e);
        });
        markers = []
        p1 = teditor.session.getDocument().indexToPosition(x1,0);
        p2 = teditor.session.getDocument().indexToPosition(x2,0);
        range = new Range(p1.row, p1.column, p2.row, p2.column);
        markers.push(teditor.session.addMarker(range, bracket_class, "text"));
    }
    var start_time = 0;
    ws.onmessage = function (msg) {
    	//output.innerText = msg.data;
        output.innerText = "";
        t = JSON.parse(msg.data);
        console.log(t.errors)
        if (t.errors != "") {
            $('#richtext_output').text(t.errors)
            $('#result_indicator').text('error');
            return;
        }
        maxidx = t.maxidx
        $('#richtext_output').treeview({data: genJSONTree(t.entries)});
        $('#richtext_output').on('nodeSelected', onTreeNodeSelected);
        $('#richtext_output').on('nodeUnselected', onTreeNodeUnselected);
        markAllMatches(t.entries)
        exec_time = performance.now() - start_time;
        $('#result_indicator').text(Math.round(exec_time) + 'ms');
    };
    geditor.on("change", function (e) {
        jmsg = JSON.stringify({ grammar: geditor.session.getDocument().getValue(), test_string: teditor.session.getDocument().getValue() })
        start_time = performance.now();
        $('#result_indicator').text('wait');
        ws.send(jmsg);
    });

    </script>
  </body>
</html>