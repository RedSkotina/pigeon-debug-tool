<html>
  <script src="jquery-3.1.0.min.js"></script>
  <script src="tether.min.js"></script>
  <!-- Latest compiled and minified CSS -->
  <link rel="stylesheet" href="bootstrap/3.3.7/css/bootstrap.min.css">
  <!-- Optional theme -->
  <link rel="stylesheet" href="bootstrap/3.3.7/css/bootstrap-theme.min.css">
  <!-- Latest compiled and minified JavaScript -->
  <script src="bootstrap/3.3.7/js/bootstrap.min.js"></script>
  <script src="ace/ace.js" type="text/javascript" charset="utf-8"></script>
     
  <link href="app.css" rel="stylesheet" type="text/css">
  
  
  <body>
    
    <div id="desk">
        
        <div id="main_desk" class="flex-container">
            <div id="grammar_container" class="flex-grammar">
                <label for="richtext_grammar_container">PEG Grammar
                    <span id="result_indicator" class="no_match">no match</span>
                </label>
                <div id="richtext_grammar_container" class="richtext_container overflow_handler">
                    <div id="richtext_grammar" class="richtext"></div>
                </div>
            </div>
            <div id="test_container" class="flex-text">
                <label for="richtext_test_container">Test string</label>
                <div id="richtext_test_container" class="richtext_container overflow_handler">
                    <div id="richtext_test" class="richtext"></div>
                </div>
            </div>
        </div>

        <div id="info_desk" class="flex-container">
                <div id="output_container" class="flex-elem">
                    <label for="richtext_output_container">Output</label>
                    <div id="richtext_output_container" class="overflow_handler">
                        <div id="richtext_output" class="richtext">Output will be displayed here automatically.</div>
                     </div>
                </div>
        </div>
    
    </div>
        
    <script>
    var url = "ws://" + window.location.host + "/api/ws";
    var ws = new WebSocket(url);
    var output = document.getElementById("richtext_output");
    
    var geditor = ace.edit("richtext_grammar");
    geditor.setTheme("ace/theme/chrome");

    var teditor = ace.edit("richtext_test");
    teditor.setTheme("ace/theme/chrome");
    //editor.getSession().setMode("ace/mode/javascript");
    var Range = ace.require('ace/range').Range;


    //adding a tooltip
    var entries = [];
    var markers = [];    

    teditor.on("mousemove", function (e){
        var position = e.getDocumentPosition();
        if (position) {
            posIdx = teditor.session.getDocument().positionToIndex(position,0);
            r = getRangesByPosIdx(entries,posIdx);
            var text = mergeTextByPosIdx(r,posIdx);
            if (text.length > 0) {
                var pixelPosition = teditor.renderer.textToScreenCoordinates(position);
                pixelPosition.pageY += teditor.renderer.lineHeight;
                updateTooltip(pixelPosition, text);
            }else{
                updateTooltip(teditor.renderer.textToScreenCoordinates(position));
            }
            markers.forEach(function(e) {
                teditor.session.removeMarker(e);
            });
            markers = [];
            color = 0
            r.forEach(function(e) {
                coloridx = color % 4 + 1
                color += 1
                bracket_class = "mark_bracket"+coloridx
                p1 = teditor.session.getDocument().indexToPosition(e.x1,0);
                p2 = teditor.session.getDocument().indexToPosition(e.x2,0);
                range = new Range(p1.row, p1.column, p2.row, p2.column);
                markers.push(teditor.session.addMarker(range, bracket_class, "text"));
            });
            
        }
    });

    function getRangesByPosIdx(arr, idx) {
        var r = [];
        arr.forEach(function(e) {
            if ((e.x1 <= idx) && (idx < e.x2)) {
                if ((r.length > 0) && (r[0].x1 <= e.x1) && (r[0].x2 >= e.x2)) {
                    r.unshift(e);
                } else {
                    r.push(e);
                }
        }   
        })
        
        return r;
    }
    function mergeTextByPosIdx(arr, idx) {
        var text = '';
        arr.forEach(function(e) {
            if ((e.x1 <= idx ) && (idx < e.x2)) {
                text += e.text + '\n';
            }
        });
        return text
    }

    function updateTooltip(position, text){
            //example with container creation via JS
            var div = document.getElementById('rule_tooltip_0');
            if(div === null){
                div = document.createElement('div');        
                div.setAttribute('id', 'rule_tooltip_0'); 
                div.setAttribute('class', 'rule_tooltip'); // and make sure myclass has some styles in css
                document.body.appendChild(div);
            }

            div.style.left = position.pageX + 'px';
            div.style.top = position.pageY + 'px';
            if(text){
                div.style.display = "block";
                div.innerText = text;
            }else{
                div.style.display = "none";
                div.innerText = "";
            }           

        }

    
    function mark(x1, x2, text) {
        entries.push({ x1:x1, x2:x2, text: text})
    }
    
    function traverse(jsonObj) {
        if( typeof jsonObj == "object") {
            $.each(jsonObj, function(k,v) {
                if ("calls" in v) {
                    var x2
                    x1 = v.detail.pos.Pos
                    if (v.match !== null) {
                        x2 = v.match.pos.Pos;
                    } else {
                        x2 = x1;
                    }
                    mark(x1, x2, v.detail.name)
                
                    traverse(v.calls);
                }
            });
        }
        else {
            // jsonOb is a number or string
        }
    }
    var markAllMatches = function(e) {
        entries = []
        traverse(e);
   };

    ws.onmessage = function (msg) {
    	output.innerText = msg.data;
        t = JSON.parse(msg.data);
        markAllMatches(t.entries)
    };
    geditor.on("change", function (e) {
        jmsg = JSON.stringify({ grammar: geditor.session.getDocument().getValue(), test_string: teditor.session.getDocument().getValue() })
        ws.send(jmsg);
    });

    </script>
  </body>
</html>