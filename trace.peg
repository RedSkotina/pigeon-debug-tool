{
package main
/*
func main() {
	got, err := ParseReader("stdin", os.Stdin)
	if err != nil {
		log.Fatal(err)
	}
	
    //fmt.Println(got)
    strace := got.(TTrace)

	jtrace, err := json.Marshal(strace)
	if err != nil {
		log.Printf("Cant marshal json\n")
	}
    fmt.Println(jtrace)
    
} 
*/

func toIfaceSlice(v interface{}) []interface{} {
	if v == nil {
		return nil
	}
	return v.([]interface{})
}
func IfaceSliceToString(v []interface{}) string {
    if v == nil {
        return ""
    }
    buffer := bytes.Buffer{}
    for i := range v {
        buffer.WriteString(string(toIfaceSlice(v[i])[1].([]uint8)))
    }
    return buffer.String()
}

func IfaceSliceToEntrySlice(a []interface{}) []TEntry {
    if a == nil {
        return []TEntry{}
    }
    g := make([]TEntry, 0, len(a))
    for _, v := range a {
        g = append(g, v.(TEntry))
    }
    return g
}

type TDetail struct {
    Idx1  int      `json:"idx1"`
    Idx2  int      `json:"idx2"`
    Name string    `json:"name"`
}

type TEntry struct {
    Detail TDetail `json:"detail"`
    Calls []TEntry `json:"calls"`
    IsMatch bool  `json:"ismatch"`
}

type TTrace struct {
    Entries []TEntry `json:"entries"`
    Errors string    `json:"errors"`
}

func isNotNull(m interface{}) bool {
    if m == nil {
        return false
    }
    return true
}

func matchPos(m interface{}, defaultIdx int) int {
    if isNotNull(m) {
        return m.(int)
    }
    return defaultIdx
}

}

Trace <- #{state["indent"]=1; return nil} lines:(TraceLine)* { return TTrace{IfaceSliceToEntrySlice(toIfaceSlice(lines)), ""}, nil }
TraceLine <- INDENTATION entry:TraceEntry  { return entry, nil }

TraceEntry <-  INDENT enter:EnterParseEntry calls:(TraceEntry / RestoreEntry)* match:MatchEntry? DEDENT exit:ExitParseEntry 
    { return TEntry{
                TDetail{ enter.(TDetail).Idx1, matchPos(match, exit.(TDetail).Idx2), enter.(TDetail).Name },
                IfaceSliceToEntrySlice(toIfaceSlice(calls)),
                isNotNull(match),
                },
                nil }
EnterParseEntry <- _* '>' _ pos:Position _ "parse" text:(!Cursor .)* cur:Cursor NL
    { return TDetail{Idx1: pos.(int), Name: IfaceSliceToString(toIfaceSlice(text)) }, nil }
ExitParseEntry  <- _* '<' _ pos:Position _ "parse" text:(!Cursor .)* cur:Cursor NL
    { return TDetail{Idx2: pos.(int), Name: IfaceSliceToString(toIfaceSlice(text)) }, nil }

RestoreEntry <- INDENT enter:EnterRestoreEntry DEDENT exit:ExitRestoreEntry 
    { return TEntry{ 
                TDetail{ enter.(TDetail).Idx1, exit.(TDetail).Idx2, enter.(TDetail).Name },
                []TEntry{},
                 false,
                 },
                 nil }
EnterRestoreEntry    <- _* '>' _ pos:Position _ "restore" _ cur:Cursor NL
    { return TDetail{Idx1: pos.(int), Name: "restore" }, nil }
ExitRestoreEntry     <- _* '<' _ pos:Position _ "restore" _ cur:Cursor NL
    { return TDetail{Idx2: pos.(int), Name: "restore" }, nil }

MatchEntry <- _* "MATCH" _ pos:Position _ text:(!Cursor .)* cur:Cursor NL
    { return pos, nil }

Cursor <- "[U+" n:HexNumber (_ "'" . "'")? "]" { return n, nil }
Position <- line:Number ':' col:Number ':' idx:Number ':' { return idx.(int), nil }
Number <- [0-9]+ { n,err := strconv.ParseInt(string(c.text), 0, 64); return int(n), err }
HexNumber <- [0-9A-F]+ { n,err := strconv.ParseInt(string(c.text), 16, 64); return int(n), err }
NL <- "\r"? "\n" { return "", nil }
_ "whitespace" <- ' '


INDENTATION â† spaces:" "* &{ return len(toIfaceSlice(spaces)) == state["indent"].(int), nil }
INDENT <- #{state["indent"]=state["indent"].(int)+1; return nil}
DEDENT <- #{state["indent"]=state["indent"].(int)-1; return nil}