{
package main
/*
func main() {
	got, err := ParseReader("stdin", os.Stdin)
	if err != nil {
		log.Fatal(err)
	}
	
    //fmt.Println(got)
    strace := got.(Ttrace)

	jtrace, err := json.Marshal(strace)
	if err != nil {
		log.Printf("Cant marshal json\n")
	}
    fmt.Println(jtrace)
    
} 
*/
func toIfaceSlice(v interface{}) []interface{} {
	if v == nil {
		return nil
	}
	return v.([]interface{})
}
func IfaceSliceToString(v []interface{}) string {
    if v == nil {
        return ""
    }
    buffer := bytes.Buffer{}
    for i := range v {
        buffer.WriteString(string(toIfaceSlice(v[i])[1].([]uint8)))
    }
    return buffer.String()
}

func IfaceSliceToEntrySlice(a []interface{}) []Tentry {
    if a == nil {
        return []Tentry{}
    }
    g := make([]Tentry, 0, len(a))
    for _, v := range a {
        g = append(g, v.(Tentry))
    }
    return g
}

type Tposition struct {
    Line,Col,Pos int 
}
type tcursor struct {
    codepoint int 
}

type Tmatch struct {
    Pos Tposition `json:"pos"`
    Text string   `json:"text"`
}

type Tdetail struct {
    Pos Tposition `json:"pos"`
    Name string   `json:"name"`
}

type Tentry struct {
    Detail Tdetail `json:"detail"`
    Calls []Tentry `json:"calls"`
    Match *Tmatch  `json:"match"`
}

type Ttrace struct {
    Entries []Tentry `json:"entries"`
    Errors string    `json:"errors"`
    MaxIdx int       `json:"maxidx"`
}

func toMatchRef(m interface{}) *Tmatch {
    if m == nil {
        return nil
    }
    r := m.(Tmatch)
    return &r
}

}

Trace <- #{state["indent"]=1; return nil} lines:(TraceLine)* { return Ttrace{IfaceSliceToEntrySlice(toIfaceSlice(lines)),"", 0},nil }
TraceLine <- INDENTATION entry:TraceEntry  { return entry,nil }

TraceEntry <-  INDENT enter:EnterParseEntry calls:(TraceEntry / RestoreEntry)* match:MatchEntry? DEDENT ExitParseEntry 
    { return Tentry{enter.(Tdetail), IfaceSliceToEntrySlice(toIfaceSlice(calls)), toMatchRef(match)}, nil }
EnterParseEntry <- _* '>' _ pos:Position _ "parse" text:(!Cursor .)* cur:Cursor NL
    { return Tdetail{pos.(Tposition), IfaceSliceToString(toIfaceSlice(text)) }, nil }
ExitParseEntry  <- _* '<' _ pos:Position _ "parse" text:(!Cursor .)* cur:Cursor NL
    { return Tdetail{pos.(Tposition), IfaceSliceToString(toIfaceSlice(text)) }, nil }

RestoreEntry <- INDENT enter:EnterRestoreEntry DEDENT exit:ExitRestoreEntry 
    { return Tentry{enter.(Tdetail), []Tentry{}, nil}, nil }
EnterRestoreEntry    <- _* '>' _ pos:Position _ "restore" _ cur:Cursor NL
    { return Tdetail{pos.(Tposition), "restore" }, nil }
ExitRestoreEntry     <- _* '<' _ pos:Position _ "restore" _ cur:Cursor NL
    { return Tdetail{pos.(Tposition), "restore" }, nil }

MatchEntry <- _* "MATCH" _ pos:Position _ text:(!Cursor .)* cur:Cursor NL
    { return Tmatch{pos.(Tposition), IfaceSliceToString(toIfaceSlice(text))}, nil }

Cursor <- "[U+" n:HexNumber (_ "'" . "'")? "]" { return n, nil }
Position <- line:Number ':' col:Number ':' pos:Number ':' { return Tposition{line.(int),col.(int),pos.(int)}, nil }
Number <- [0-9]+ { n,err := strconv.ParseInt(string(c.text), 0, 64); return int(n),err }
HexNumber <- [0-9A-F]+ { n,err := strconv.ParseInt(string(c.text), 16, 64); return int(n),err }
NL <- "\r"? "\n" { return "", nil }
_ "whitespace" <- ' '


INDENTATION ← spaces:" "* &{ return len(toIfaceSlice(spaces)) == state["indent"].(int), nil }
INDENT <- #{state["indent"]=state["indent"].(int)+1; return nil}
DEDENT <- #{state["indent"]=state["indent"].(int)-1; return nil}